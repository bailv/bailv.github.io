<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>笔记——Docker修改镜像源</title>
      <link href="/2020/02/02/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Docker%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E6%BA%90/"/>
      <url>/2020/02/02/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Docker%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-当前命令携带-registry-mirror参数"><a href="#1-当前命令携带-registry-mirror参数" class="headerlink" title="1. 当前命令携带--registry-mirror参数"></a>1. 当前命令携带<code>--registry-mirror</code>参数</h2><p>例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world --registry-mirror=https://docker.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure><h3 id="2-使用-json-配置文件"><a href="#2-使用-json-配置文件" class="headerlink" title="2. 使用 json 配置文件"></a>2. 使用 json 配置文件</h3><p>配置文件默认路径<code>/etc/docker/daemon.json</code>，非默认路径需要修改 <code>dockerd</code>的<code>–config-file</code>，在该配置文件添加一下内容：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://md4nbj2f.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"http://registry.docker-cn.com"</span>,</span><br><span class="line">    <span class="string">"http://docker.mirrors.ustc.edu.cn"</span>,</span><br><span class="line">    <span class="string">"http://hub-mirror.c.163.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后需执行以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重载配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一刀流冲煮法</title>
      <link href="/2019/10/28/%E4%B8%80%E5%88%80%E6%B5%81%E5%86%B2%E7%85%AE%E6%B3%95/"/>
      <url>/2019/10/28/%E4%B8%80%E5%88%80%E6%B5%81%E5%86%B2%E7%85%AE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>不焖蒸，不断水</li><li>口感清爽舒适，适合大量饮用</li><li>快速萃取，萃出前段果香和果酸，body 部分不会有太多的厚度和口感</li></ul><h2 id="冲煮方法"><a href="#冲煮方法" class="headerlink" title="冲煮方法"></a>冲煮方法</h2><p>中心点大概一片指甲大小位置注水，持续注水至 250cc 左右开始往外绕圈，再绕回中心，300cc 收水</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td><strong>研磨度</strong></td><td>正常手冲研磨度</td></tr><tr><td><strong>粉量</strong></td><td>20g</td></tr><tr><td><strong>水粉比</strong></td><td>1:15</td></tr><tr><td><strong>水温</strong></td><td>90℃</td></tr><tr><td><strong>水流</strong></td><td>适中</td></tr><tr><td><strong>时间</strong></td><td>1 分 10 秒左右</td></tr></tbody></table><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><ul><li>如果整体风味偏浓郁，可通过将==研磨度==相对调粗；相反调细研磨度使风味浓郁</li><li>如果想降低酸味，可通过将==水流大小相对<strong>调小</strong>==，使得甜感变得显著，酸感降低</li><li>如果感觉口感偏苦涩不够酸感，则可以通过将==水流相对<strong>调大</strong>==</li></ul>]]></content>
      
      
      <categories>
          
          <category> 咖啡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记——Web Components</title>
      <link href="/2019/10/25/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Web%20Components/"/>
      <url>/2019/10/25/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Web%20Components/</url>
      
        <content type="html"><![CDATA[<h2 id="四个核心"><a href="#四个核心" class="headerlink" title="四个核心"></a>四个核心</h2><p>HTML 和 DOM 标准定义了四种新的标准来帮助定义 Web Component。这些标准如下：</p><ul><li>自定义元素（Custom Elements）：定义新 HTML 元素的一系列 API；</li><li>影子 DOM（Shadow DOM）：组合对 DOM 和样式的封装；</li><li>HTML 导入（HTML Imports）：定义在文档中导入其他 HTML 文档的方式；</li><li>HTML 模板（HTML Templates）：HTML 内的 DOM 模板，在<template>元素内声明。</template></li></ul><h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p>自定义元素支持开发者定义一类新 HTML 元素，声明其行为和样式，自定义元素分两类：</p><ul><li>自定义标签元素（Autonomous custom elements）：完全独立于原始 HTML 元素标签的新标签元素，其所有行为需要开发者定义；</li><li>自定义内置元素（Customized built-in）：基于 HTML 原始元素标签的自定义元素，以便于使用原始元素的特性，开发者只需要定义拓展行为；</li></ul><h3 id="自定义标签元素"><a href="#自定义标签元素" class="headerlink" title="自定义标签元素"></a>自定义标签元素</h3><p>创建一个自定义标签元素，我们需要继承 HTMLELement 类<br>自定义元素具有以下生命周期回调函数：</p><ul><li><code>connectedCallback</code> — 每当元素插入 DOM 时被触发。</li><li><code>disconnectedCallback</code> — 每当元素从 DOM 中移除时被触发。</li><li><code>attributeChangedCallback</code> — 当元素上的属性被添加、移除、更新或取代时被触发。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册自定义元素</span></span><br><span class="line">customElements.define(<span class="string">'test-ele'</span>, TestElement);</span><br></pre></td></tr></table></figure><p>在需要使用该组件的页面只需像使用正常 HTML 元素一样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test-ele</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">test-ele</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义内置元素"><a href="#自定义内置元素" class="headerlink" title="自定义内置元素"></a>自定义内置元素</h3><p>很多时候我们并不需要完全创建一个新元素，而只是需要在某些内置元素基础上进行拓展，创建自定义内置元素，需要继承该类元素类，如 HTMLButtonElement 或 HTMLDivElement：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">customElements.define(<span class="string">'menu-button'</span>, MenuButton);</span><br></pre></td></tr></table></figure><p>使用也很简单，和内置元素一样的语法；不同的是，在需要使用自定义内置元素时，为内置元素添加 is 特性，该特性值对应创建的自定义内置元素名称:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"menu-button"</span>&gt;</span>menu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>通过上面实例可知，自定义标签元素与内置元素主要表现在两点不同：</p><ul><li>标签：自定义标签元素是完全独立的一个新元素，新标签，而自定义内置标签，使用的依然是已有内置标签；</li><li>行为与样式：自定义内置元素，继承内置元素的默认行为，样式及语义，可以进行拓展，而自定义标签元素，完全需要开发者定义相关声明。</li></ul><h2 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h2><p>文档 DOM 树的层次结构中是不存在局部作用域概念的，也就是说文档内所有定义的样式都对整个文档产生影响，文档中的样式也会影响组件内的声明样式，而不限定于元素所处位置，这样显然极大阻碍了组件的独立性和可重用性</p><p>影子 DOM API 提供了<code>attachShadow()</code>方法，创建一个影子 DOM，支持将封装的内容或组件作为一个独立 DOM 子树附加进一个 HTML 文档，组件内与外部隔离，样式互不影响，这也印证了组件开发的封装性需求。</p><h3 id="影子树（SHADOW-TREE）与影子主体（SHADOW-HOST）"><a href="#影子树（SHADOW-TREE）与影子主体（SHADOW-HOST）" class="headerlink" title="影子树（SHADOW TREE）与影子主体（SHADOW HOST）"></a>影子树（SHADOW TREE）与影子主体（SHADOW HOST）</h3><p>使用<code>attachShadow()</code>方法创建的元素就是一个影子 DOM，而其子内容就构成一棵影子树（shadow tree），而和影子 DOM 绑定，也就是包含该树的文档内元素通常称为影子主体（shadow host）。</p><h3 id="创建使用"><a href="#创建使用" class="headerlink" title="创建使用"></a>创建使用</h3><p>使用 Shadow DOM，我们需要在一个元素上创建一个影子主体，然后将模板内文档添加到这个主体上即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> shadowRoot = frag.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;);</span><br><span class="line">shadowRoot.innerHTML = <span class="string">'&lt;p&gt;Shadow DOM Content&lt;/p&gt;'</span>;</span><br></pre></td></tr></table></figure><h3 id="槽位（SLOT）"><a href="#槽位（SLOT）" class="headerlink" title="槽位（SLOT）"></a>槽位（SLOT）</h3><p>当一个元素（即影子主体）内存在影子 DOM，浏览器默认只会渲染该影子 DOM 的影子树，而不渲染影子主体的其他子内容。<br>如果要保存子内容，需要使用<code>&lt;slot&gt;</code>槽位元素，相当于做一个占位符</p><p>eg.<br>给 menu 元素绑定子 DOM:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menus = <span class="built_in">document</span>.querySelector(<span class="string">'.menus'</span>);</span><br><span class="line"><span class="keyword">var</span> shadowRoot = menus.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;);</span><br><span class="line">shadowRoot.innerHTML =</span><br><span class="line">  <span class="string">'&lt;ul&gt;\</span></span><br><span class="line"><span class="string">        &lt;li&gt;Home&lt;/li&gt;\</span></span><br><span class="line"><span class="string">        &lt;li&gt;About&lt;/li&gt;\</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menus"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Menus<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//渲染结果,slot被替代</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menus"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Menus<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>About<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>命名槽（named slots）</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//影子主体</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menus"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//影子树内容</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Menus<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">slot</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>About<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">slot</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Top<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//渲染结果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menus"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Menus<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>About<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Top<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>拥有 name 属性的槽位由对应 slot 属性值相同的影子子树替换，而剩下的内容默认替换空名槽位，若不存在空名槽位，则剩余内容将被抛弃。</p><h2 id="HTML-模板（HTML-Templates）"><a href="#HTML-模板（HTML-Templates）" class="headerlink" title="HTML 模板（HTML Templates）"></a>HTML 模板（HTML Templates）</h2><p>为了更友好的处理组件模板，Web Components 规范，支持<code>&lt;template&gt;</code>模板标签，HTML 模板定义了使用<code>&lt;template&gt;</code>标签声明可以通过脚本操作插入文档的 HTML 模板片段：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"menusTemplate"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>About<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JS 就可以访问到模板，并将其插入 DOM 中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menusTemplate = <span class="built_in">document</span>.querySelector(<span class="string">'#menusTemplate'</span>);</span><br><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.importNode(menusTemplate.content, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.menus'</span>).appendChild(frag);</span><br></pre></td></tr></table></figure><h3 id="TEMPLATE-标签"><a href="#TEMPLATE-标签" class="headerlink" title="TEMPLATE 标签"></a>TEMPLATE 标签</h3><p><code>&lt;template&gt;</code>标签本质上与其他 HTML 内置标签一样，可以使用 DOM API 进行操作，但是需要明白，在将模板激活（生成 DOM 或插入文档）前：</p><ol><li><code>&lt;template&gt;</code>标签内的内容不会被渲染；</li><li>标签内的图片，等媒体资源不会被加载；</li><li>标签不会出现在 DOM 树，审查元素看不到；</li></ol><h2 id="HTML-引入（HTML-Imports）"><a href="#HTML-引入（HTML-Imports）" class="headerlink" title="HTML 引入（HTML Imports）"></a>HTML 引入（HTML Imports）</h2><p>在文档内直接引入外链资源的文档或 web 组件，语法如下，使用<code>&lt;link&gt;</code>标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span> <span class="attr">href</span>=<span class="string">"components.html"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>为了避免重复执行引入文档内的脚本，对于已加载文档，import 方式将跳过其加载和执行过程。</p><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><ol><li>创建自定义元素/自定义内置元素</li><li>编写 html 模板</li><li>自定义元素绑定 ShadowDOM</li><li>导入使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记:利用记忆化技术提升React性能</title>
      <link href="/2019/10/09/%E7%AC%94%E8%AE%B0-%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87React%E6%80%A7%E8%83%BD/"/>
      <url>/2019/10/09/%E7%AC%94%E8%AE%B0-%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87React%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="记忆化技术"><a href="#记忆化技术" class="headerlink" title="记忆化技术"></a>记忆化技术</h2><p>望文生义，记忆化就是把函数的调用结果记录下来或者缓存下来。下次调用这个函数的时候，如输入参数和上一次完全一致，则无需再次计算，直接返回上一次的结果。</p><h2 id="使用动机"><a href="#使用动机" class="headerlink" title="使用动机"></a>使用动机</h2><p>React项目中，有一个场景很常见：从api请求拿到一个复杂的数据结构，该数据一般通过React组件的<code>props</code>传入组件。而当前组件只需展示部分的数据，因此在<code>render</code>的时候需对该数据进行处理，如过滤一些无用的信息或者重新组合该数据结构。</p><p>而我们知道<code>state</code>和<code>props</code>频繁修改会触发<code>render</code>。有时候组件的更新并不是因为重新请求api返回的数据结构导致变化，但对数据的处理逻辑都是在<code>render</code>中，因此不可避免每次<code>render</code>都对数据进行一次无用的处理，造成性能浪费。</p><h2 id="memoize-one"><a href="#memoize-one" class="headerlink" title="memoize-one"></a>memoize-one</h2><p>借助memoize-one这个库，我们可以实现本来需要 O(n) ，O(n2) 甚至更高复杂度的算法，我们瞬间可以以 O(1) 的效率把结果直接从缓存中读取出来。</p><p>memoize-one是采用闭包来缓存数据的，其源码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type EqualityFn = <span class="function">(<span class="params">a: mixed, b: mixed</span>) =&gt;</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleIsEqual: EqualityFn = (a: mixed, <span class="attr">b</span>: mixed): <span class="function"><span class="params">boolean</span> =&gt;</span> a === b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> &lt;<span class="title">ResultFn</span>: (<span class="params">...Array&lt;any&gt;</span>) =&gt; <span class="title">mixed</span>&gt;(<span class="params">resultFn: ResultFn, isEqual?: EqualityFn = simpleIsEqual</span>): <span class="title">ResultFn</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastThis: mixed; <span class="comment">// 用来缓存上一次result函数对象</span></span><br><span class="line">  <span class="keyword">let</span> lastArgs: <span class="built_in">Array</span>&lt;mixed&gt; = []; <span class="comment">// 用来缓存上一次的传参</span></span><br><span class="line">  <span class="keyword">let</span> lastResult: mixed; <span class="comment">// 用来缓存上一次的结果</span></span><br><span class="line">  <span class="keyword">let</span> calledOnce: boolean = <span class="literal">false</span>; <span class="comment">// 是否之前调用过</span></span><br><span class="line">  <span class="comment">// 判断两次调用的时候的参数是否相等</span></span><br><span class="line">  <span class="comment">// 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等</span></span><br><span class="line">  <span class="keyword">const</span> isNewArgEqualToLast = (newArg: mixed, <span class="attr">index</span>: number): <span class="function"><span class="params">boolean</span> =&gt;</span> isEqual(newArg, lastArgs[index]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="function"><span class="keyword">function</span> (<span class="params">...newArgs: Array&lt;mixed&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (calledOnce &amp;&amp;</span><br><span class="line">      lastThis === <span class="keyword">this</span> &amp;&amp;</span><br><span class="line">      newArgs.length === lastArgs.length &amp;&amp;</span><br><span class="line">      newArgs.every(isNewArgEqualToLast)) &#123;</span><br><span class="line">      <span class="comment">// 返回之前的结果</span></span><br><span class="line">      <span class="keyword">return</span> lastResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calledOnce = <span class="literal">true</span>; <span class="comment">// 标记已经调用过</span></span><br><span class="line">    lastThis = <span class="keyword">this</span>; <span class="comment">// 重新缓存result对象</span></span><br><span class="line">    lastArgs = newArgs; <span class="comment">// 重新缓存参数</span></span><br><span class="line">    lastResult = resultFn.apply(<span class="keyword">this</span>, newArgs); <span class="comment">// 重新缓存结果</span></span><br><span class="line">    <span class="keyword">return</span> lastResult; <span class="comment">// 返回新的结果</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回闭包函数</span></span><br><span class="line">  <span class="keyword">return</span> (result: any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isEqual参数"><a href="#isEqual参数" class="headerlink" title="isEqual参数"></a>isEqual参数</h3><p>一般两个对象比较是否相等，我们不能用<code>===</code>或者<code>==</code>来处理，memoize-one允许用户自定义传入判断是否相等的函数。官方推荐使用<code>lodash.isEqual</code></p><h2 id="React-Hook-useMemo"><a href="#React-Hook-useMemo" class="headerlink" title="React Hook useMemo"></a>React Hook useMemo</h2><p>React 16.8引入Hook。其中官方提供了原生的记忆化API——<code>useMemo</code>。<br>具体的使用方法参考<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/37913276" target="_blank" rel="noopener">记忆化技术介绍——使用闭包提升你的 React 性能</a><br><a href="https://segmentfault.com/a/1190000015301672" target="_blank" rel="noopener">React优化-记忆化技术-使用闭包提升你的React性能</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记——浏览器JavaScript执行机制</title>
      <link href="/2019/08/13/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/13/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="单线程的-JavaScript"><a href="#单线程的-JavaScript" class="headerlink" title="单线程的 JavaScript"></a>单线程的 JavaScript</h2><p>JS 被设计为单线程运行的，这是因为 JS 主要用来实现很多交互相关的操作，如 DOM 相关操作，如果是多线程会造成复杂的同步问题。</p><p>因此浏览器在运行时只开启了一个 JS 引擎线程来解析和执行 JS。那为什么只有一个引擎呢？如果同时有两个线程去操作 DOM，浏览器是不是又要不知所措了。</p><blockquote><p>JS 引擎可以说是 JS 虚拟机，负责 JS 代码的解析和执行。通常包括以下几个步骤：</p><ul><li>词法分析：将源代码分解为有意义的分词</li><li>语法分析：用语法分析器将分词解析成语法树</li><li>代码生成：生成机器能运行的代码</li><li>代码执行</li></ul></blockquote><p>虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的。你的一些 I/O 操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</p><blockquote><p>一个浏览器通常由以下几个常驻的线程</p><ul><li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li><li>JS 引擎线程：负责 JS 的解析和执行</li><li>定时触发器线程：处理定时事件，比如 setTimeout, setInterval</li><li>事件触发线程：处理 DOM 事件</li><li>异步 http 请求线程：处理 http 请求</li></ul></blockquote><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>单线程就意味着，所有任务需要排队。任务队列中，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。因此一些耗时的操作如 I/O，http 请求等任务可以先挂起，主线程先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><h3 id="JavaScript-中将任务分为两种"><a href="#JavaScript-中将任务分为两种" class="headerlink" title="JavaScript 中将任务分为两种"></a>JavaScript 中将任务分为两种</h3><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。异步执行的运行机制如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p><img src="https://raw.githubusercontent.com/clanaid/pic_repository/master/img/bg2014100801.jpg" alt></p><h3 id="任务规范"><a href="#任务规范" class="headerlink" title="任务规范"></a>任务规范</h3><p>在任务队列中存放的是一个个<code>任务(Task)</code>。规范中规定，<strong>Task 分为两大类, 分别是 Macro Task(宏任务) 和 Micro Task(微任务)</strong>，并且每个 Macro Task 结束后, 都要清空所有的 Micro Task. 其中 Micro Task 细分为两个队列——<code>Micro Task Queue</code>() 和 <code>Tick Task Queue</code>(专门用于存放 process.nextTick 的任务). <code>Tick Task</code>任务优先于<code>Micro Task</code>任务执行</p><h4 id="Macro-Task"><a href="#Macro-Task" class="headerlink" title="Macro Task"></a>Macro Task</h4><p>每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p><p>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它<br>浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</p><p>包含：</p><ul><li>setImmediate</li><li>setTimeout</li><li>setInterval</li></ul><h4 id="Micro-Task"><a href="#Micro-Task" class="headerlink" title="Micro Task"></a>Micro Task</h4><p>所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护</p><p>包含：</p><ul><li>process.nextTick</li><li>Promise</li><li>Object.observe</li><li>MutaionObserver</li></ul><p><img src="https://raw.githubusercontent.com/clanaid/pic_repository/master/img/20190813164356.png" alt></p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>从上述任务队列中可以知道，主线程从任务队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这一机制称为<strong>事件循环</strong>。</p><p>主线程运行的时候，产生<code>堆（heap）</code>和<code>栈（stack）</code>。</p><p>栈存放大量的同步任务，同时如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p><p>堆用来存储声明的变量、对象。</p><p>某个异步任务有了响应就会被推入 callback 队列中。如用户的点击事件、浏览器收到服务的响应和 setTimeout 中待执行的事件，每个异步任务都和回调函数相关联。</p><p>主线程执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p><p><img src="https://raw.githubusercontent.com/clanaid/pic_repository/master/img/20190813172912.png" alt></p><p>执行流程如图所示：</p><p><img src="https://raw.githubusercontent.com/clanaid/pic_repository/master/img/20190813171334.png" alt></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>参考文章</strong></p><p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8" target="_blank" rel="noopener">JavaScript 异步机制详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/33104163" target="_blank" rel="noopener">JavaScript 中的 JS 引擎的执行机制：探究 Event Loop</a></p><p><a href="https://github.com/pramper/Blog/issues/4" target="_blank" rel="noopener">JavaScript 单线程和异步机制</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React笔记——React Fragment</title>
      <link href="/2019/06/12/React%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94React%20Fragment/"/>
      <url>/2019/06/12/React%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94React%20Fragment/</url>
      
        <content type="html"><![CDATA[<h3 id="只支持单元素渲染"><a href="#只支持单元素渲染" class="headerlink" title="只支持单元素渲染"></a>只支持单元素渲染</h3><p>React 16 之前，子组件的渲染只支持单个元素，<code>render</code>函数的返回必须有一个根节点，通常使用一个<code>div</code>或<code>span</code>。</p><h3 id="返回多元素数组"><a href="#返回多元素数组" class="headerlink" title="返回多元素数组"></a>返回多元素数组</h3><p>而在 React 16 之后，增加了对组件的<code>render</code>方法返回一个包含元素的数组的支持。你可以将其他们放进数组里，而不用将子元素包装在一个 DOM 元素内：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"text"</span>,</span><br><span class="line">    &lt;h2&gt;Head2&lt;<span class="regexp">/h2&gt;,</span></span><br><span class="line"><span class="regexp">    "text",</span></span><br><span class="line"><span class="regexp">    &lt;h3&gt;Head3&lt;/</span>h3&gt;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><p>React 16 提供了<code>Fragment</code>组件来替代数组的写法，提供一致性的 JSX 开发</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            Text.</span><br><span class="line">            &lt;h2&gt;Head2&lt;/h2&gt;</span><br><span class="line">            Text.</span><br><span class="line">            &lt;h3&gt;Head3&lt;/h3&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法棒简写-lt-gt-lt-gt"><a href="#语法棒简写-lt-gt-lt-gt" class="headerlink" title="语法棒简写&lt;&gt;&lt;/&gt;"></a>语法棒简写<code>&lt;&gt;&lt;/&gt;</code></h3><p>JSX 增加了<code>fragment</code>的语法支持，可简写为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Text.</span><br><span class="line">            &lt;h2&gt;Head2&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            Text.</span></span><br><span class="line"><span class="regexp">            &lt;h3&gt;Head3&lt;/</span>h3&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;&gt;&lt;/&gt;</code>是<code>&lt;React.Fragment /&gt;</code>的语法糖</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习——设计模式:工厂模式</title>
      <link href="/2019/05/16/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/16/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：</p><ul><li><p>工厂类过于庞大，包含了大量的<code>if…else…</code>代码，导致维护和测试难度增大。</p></li><li><p>系统扩展不灵活，如果增加新类型的产品，必须修改静态工厂方法的业务逻辑，违反了<code>“开闭原则”</code>。</p></li></ul><p>此外，在简单工厂模式中，<em>所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性</em>，而工厂方法模式则可以很好地解决这一问题。</p><h2 id="模式详解"><a href="#模式详解" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="工厂模式定义："><a href="#工厂模式定义：" class="headerlink" title="工厂模式定义："></a>工厂模式定义：</h3><blockquote><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p></blockquote><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><p>工厂模式包括以下角色：</p><ul><li><p><strong>Factor： 抽象工厂</strong></p><p>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p></li><li><p><strong>ConcreteProduct： 具体工厂</strong></p><p>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p></li><li><p><strong>Product：抽象产品</strong></p><p>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</p></li><li><p><strong>ConcreteProduct：具体产品</strong></p><p>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应</p></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>与简单工厂模式相比，工厂模式引入了抽象工厂角色类，该类可以是接口、抽象类或者具体类。<br>抽象工厂代码表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工厂模式中，具体的产品创建由相应的工厂子类负责，客户端针对抽象工厂编程，在运行时指定具体的工厂类。<br>具体工厂类实现了工厂方法，不同的工厂创建不同的产品，代码表示如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象产品和具体产品类的定义与简单工厂模式一样。</strong></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p></li><li><p>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p></li><li><p>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p></li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p></li><li><p>增加或者删除同类的产品时：首先增加或者删除一个具体的产品，然后增加或者删除产品工厂。</p></li><li><p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。</p></li></ul><h2 id="什么情况会用"><a href="#什么情况会用" class="headerlink" title="什么情况会用"></a>什么情况会用</h2><p>在以下情况下可以使用工厂方法模式：</p><ul><li><p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p></li><li><p>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></li><li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>参考博客</p><ul><li><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html" target="_blank" rel="noopener">工厂方法模式(Factory Method Pattern)</a></p></li><li><p><a href="http://blog.csdn.net/lovelion/article/details/9306745" target="_blank" rel="noopener"> 工厂三兄弟之工厂方法模式（二）</a></p></li><li><p><a href="https://wizardforcel.gitbooks.io/design-pattern-lessons/content/lesson10.html" target="_blank" rel="noopener">工厂方法模式(Factory Method pattern)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日学习——设计模式:简单工厂模式</title>
      <link href="/2019/05/14/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/14/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>一个简单的例子——计算器。一个计算器软件可以提供多种不同运算操作（如加减乘除、平方根、立方根等），这些运算操作都可以派生继承同一个父类。使用者无需知道具体的运算操作类，只需知道表示该运算符的一个参数，并将其传入调用方法中便可得到相应的操作符对象，此时便可使用简单工厂模式。</p><h2 id="模式详解"><a href="#模式详解" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="简单工厂模式定义如下："><a href="#简单工厂模式定义如下：" class="headerlink" title="简单工厂模式定义如下："></a>简单工厂模式定义如下：</h3><blockquote><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p></blockquote><p>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</strong>。其核心在于<code>工厂类</code>的设计</p><h3 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h3><p>简单工厂包含以下角色：</p><ul><li><p><strong>Factory：工厂角色</strong></p><p>工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。</p></li><li><p><strong>Product：抽象产品角色</strong></p><p>它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p></li><li><p><strong>ConcreteProduct：具体产品角色</strong></p><p>它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以开头例子计算器为例：<br><code>抽象产品类</code>是运算符：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> NumberA;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> NumberB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstart <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>具体产品类</code>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">return</span> NumberA + NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">return</span> NumberA - NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...等等</span></span><br></pre></td></tr></table></figure><p><code>工厂类</code>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> operation <span class="title">createOperate</span><span class="params">(string operate)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Operation oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationAdd();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationSub();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationMul();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationDiv();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户调用端代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Operation oper;</span><br><span class="line">oper = OperationFactory.createOperate(<span class="string">"+"</span>);<span class="comment">//通过工厂类创建对象</span></span><br><span class="line">oper.NumberA = <span class="number">1</span>;</span><br><span class="line">oper.NumberB = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> result = oper.GetResult();</span><br></pre></td></tr></table></figure><p>使用者只需调用<code>工厂类</code>即可，当需拓展时只需编写相应的操作类并从工厂中创建返回，或是更换类操作类名等，只需修改<code>工厂类函数</code>便可。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</p></li><li><p>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</p></li><li><p>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p></li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><p>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p></li><li><p>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</p></li><li><p>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p></li><li><p>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></li></ul><h2 id="什么情况会用"><a href="#什么情况会用" class="headerlink" title="什么情况会用"></a>什么情况会用</h2><p>在以下情况下可以使用简单工厂模式：</p><ul><li><p>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p></li><li><p>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>参考博客</p><ul><li><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html" target="_blank" rel="noopener">简单工厂模式( Simple Factory Pattern )</a></p></li><li><p><a href="http://blog.csdn.net/lovelion/article/details/9300549" target="_blank" rel="noopener">厂三兄弟之简单工厂模式（二）</a></p></li><li><p><a href="https://wizardforcel.gitbooks.io/design-pattern-lessons/content/lesson1.html" target="_blank" rel="noopener">简单工厂模式</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node的文件路径</title>
      <link href="/2019/04/30/Node%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/04/30/Node%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>Node 中的文件路径大概有<code>__dirname</code>,<code>__filename</code>,<code>process.cwd()</code>, <code>./</code> 或者 <code>../</code>，前三个都是绝对路径，为了便于比较，<code>./</code>和<code>../</code>我们通过 <code>path.resolve(&#39;./&#39;)</code>来转换为绝对路径。</p><p>例如当前的文件结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">app/</span><br><span class="line">    -lib/</span><br><span class="line">        -common.js</span><br><span class="line">    -model</span><br><span class="line">        -tesk.js</span><br><span class="line">        -test.js</span><br></pre></td></tr></table></figure><p>在<code>model/task.js</code>中编写如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./'</span>));</span><br></pre></td></tr></table></figure><p>在<code>mode/test.js</code>中编写如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> common = <span class="built_in">require</span>(<span class="string">'../lib/common'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'../lib/common.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>app</code>目录下，执行<code>node model/task.js</code>，得到的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="variable">$dir</span>/app/model</span><br><span class="line">/<span class="variable">$dir</span>/app/model/task.js</span><br><span class="line">/<span class="variable">$dir</span>/app</span><br><span class="line">/<span class="variable">$dir</span>/app</span><br></pre></td></tr></table></figure><p>执行<code>node model/test.js</code>，会报路劲错误，<code>readFile</code>找不到<code>../lib/common.js</code>路劲</p><p><strong>结论：</strong></p><ul><li><code>__dirname</code>: 总是返回被执行的 js 所在文件夹的绝对路径</li><li><code>__filename</code>: 总是返回被执行的 js 的绝对路径</li><li><code>process.cwd()</code>: 总是返回运行 node 命令时所在的文件夹的绝对路径</li><li><code>../</code>: 在<code>require()</code>中使用,返回被运行的 js 所在的上一层文件夹路劲,其他情况下返回运行 node 命令时所在的上一层文件夹路劲</li><li><code>./</code>: 在<code>require()</code>中使用是跟<code>__dirname</code>的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟<code>process.cwd()</code>效果相同，是相对于启动脚本所在目录的路径。</li></ul><p>只有在<code>require()</code>时才使用相对路径<code>(./, ../)</code>的写法，其他地方一律使用绝对路径，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前目录下</span></span><br><span class="line">path.dirname(__filename) + <span class="string">'/test.js'</span>;</span><br><span class="line"><span class="comment">// 相邻目录下</span></span><br><span class="line">path.resolve(__dirname, <span class="string">'../lib/common.js'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
